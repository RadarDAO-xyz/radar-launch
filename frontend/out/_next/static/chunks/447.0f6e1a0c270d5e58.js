(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[447,848,833],{30666:function(t,n,e){"use strict";e.d(n,{PhantomAdapter:function(){return l}});var i=e(4942),s=e(61674),o=e(16068),a=e(4245);let r=async function(){var t;let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{interval:1e3,count:3},e="undefined"!=typeof window&&!!(null!==(t=window.solana)&&void 0!==t&&t.isPhantom);if(e)return window.solana;let i=await function t(n,e,i){return new Promise((s,o)=>{i>0?setTimeout(async()=>{let a=await n();a&&s(a),a||t(n,e,i-1).then(t=>(s(t),t)).catch(t=>o(t))},e):s(!1)})}(()=>{var t;return null===(t=window.solana)||void 0===t?void 0:t.isPhantom},n.interval,n.count);return i?window.solana:null};class l extends o.v{constructor(){super(...arguments),(0,i.Z)(this,"name",s.rW.PHANTOM),(0,i.Z)(this,"adapterNamespace",s.yk.SOLANA),(0,i.Z)(this,"currentChainNamespace",s.EN.SOLANA),(0,i.Z)(this,"type",s.hN.EXTERNAL),(0,i.Z)(this,"status",s.MP.NOT_READY),(0,i.Z)(this,"_wallet",null),(0,i.Z)(this,"phantomProvider",null),(0,i.Z)(this,"_onDisconnect",()=>{this._wallet&&(this._wallet.off("disconnect",this._onDisconnect),this.rehydrated=!1,this.status=this.status===s.MP.CONNECTED?s.MP.READY:s.MP.NOT_READY,this.emit(s.n2.DISCONNECTED))})}get isWalletConnected(){var t;return!!(null!==(t=this._wallet)&&void 0!==t&&t.isConnected&&this.status===s.MP.CONNECTED)}get provider(){var t;return(null===(t=this.phantomProvider)||void 0===t?void 0:t.provider)||null}set provider(t){throw Error("Not implemented")}async init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this._wallet=await r({interval:500,count:3}),!this._wallet)throw s.Ty.notInstalled();this.phantomProvider=new a.kL({config:{chainConfig:this.chainConfig}}),this.status=s.MP.READY,this.emit(s.n2.READY,s.rW.PHANTOM);try{s.cM.debug("initializing phantom adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(t){s.cM.error("Failed to connect with cached phantom provider",t),this.emit("ERRORED",t)}}async connect(){var t=this;try{if(super.checkConnectionRequirements(),this.status=s.MP.CONNECTING,this.emit(s.n2.CONNECTING,{adapter:s.rW.PHANTOM}),!this._wallet)throw s.Ty.notInstalled();if(this._wallet.isConnected)await this.connectWithProvider(this._wallet);else{let n=this._wallet._handleDisconnect;try{await new Promise((e,i)=>{let o=async()=>{await this.connectWithProvider(this._wallet),e(this.provider)};if(!this._wallet){i(s.Ty.notInstalled());return}this._wallet.once("connect",o),this._wallet._handleDisconnect=function(){i(s.Ty.windowClosed());for(var e=arguments.length,o=Array(e),a=0;a<e;a++)o[a]=arguments[a];return n.apply(t._wallet,o)},this._wallet.connect().catch(t=>{i(t)})})}catch(t){if(t instanceof s.up)throw t;throw s.RM.connectionError(null==t?void 0:t.message)}finally{this._wallet._handleDisconnect=n}}if(!this._wallet.publicKey)throw s.RM.connectionError();return this._wallet.on("disconnect",this._onDisconnect),this.provider}catch(t){throw this.status=s.MP.READY,this.rehydrated=!1,this.emit(s.n2.ERRORED,t),t}}async disconnect(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnectSession();try{var n;await (null===(n=this._wallet)||void 0===n?void 0:n.disconnect()),t.cleanup&&(this.status=s.MP.NOT_READY,this.phantomProvider=null,this._wallet=null),await super.disconnect()}catch(t){this.emit(s.n2.ERRORED,s.RM.disconnectionError(null==t?void 0:t.message))}}async getUserInfo(){if(!this.isWalletConnected)throw s.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async connectWithProvider(t){if(!this.phantomProvider)throw s.RM.connectionError("No phantom provider");return await this.phantomProvider.setupProvider(t),this.status=s.MP.CONNECTED,this.emit(s.n2.CONNECTED,{adapter:s.rW.PHANTOM,reconnected:this.rehydrated}),this.provider}}},78848:function(){}}]);