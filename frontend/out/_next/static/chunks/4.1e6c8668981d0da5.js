"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4],{92003:function(t){t.exports=function({mustBeMetaMask:t=!1,silent:e=!1,timeout:i=3e3}={}){!function(){if("boolean"!=typeof t)throw Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");if("boolean"!=typeof e)throw Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");if("number"!=typeof i)throw Error("@metamask/detect-provider: Expected option 'timeout' to be a number.")}();let r=!1;return new Promise(a=>{window.ethereum?n():(window.addEventListener("ethereum#initialized",n,{once:!0}),setTimeout(()=>{n()},i));function n(){if(r)return;r=!0,window.removeEventListener("ethereum#initialized",n);let{ethereum:i}=window;if(i&&(!t||i.isMetaMask))a(i);else{let r=t&&i?"Non-MetaMask window.ethereum detected.":"Unable to detect window.ethereum.";e||console.error("@metamask/detect-provider:",r),a(null)}}})}},82004:function(t,e,i){i.d(e,{MetamaskAdapter:function(){return c}});var r=i(4942),a=i(92003),n=i.n(a),s=i(61674),o=i(88907);class c extends o.d{constructor(){super(...arguments),(0,r.Z)(this,"adapterNamespace",s.yk.EIP155),(0,r.Z)(this,"currentChainNamespace",s.EN.EIP155),(0,r.Z)(this,"type",s.hN.EXTERNAL),(0,r.Z)(this,"name",s.rW.METAMASK),(0,r.Z)(this,"status",s.MP.NOT_READY),(0,r.Z)(this,"metamaskProvider",null)}get provider(){return this.status===s.MP.CONNECTED&&this.metamaskProvider?this.metamaskProvider:null}set provider(t){throw Error("Not implemented")}async init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this.metamaskProvider=await n()({mustBeMetaMask:!0}),!this.metamaskProvider)throw s.Ty.notInstalled("Metamask extension is not installed");this.status=s.MP.READY,this.emit(s.n2.READY,s.rW.METAMASK);try{s.cM.debug("initializing metamask adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(t){this.emit(s.n2.ERRORED,t)}}async connect(){if(super.checkConnectionRequirements(),!this.metamaskProvider)throw s.RM.notConnectedError("Not able to connect with metamask");this.status=s.MP.CONNECTING,this.emit(s.n2.CONNECTING,{adapter:s.rW.METAMASK});try{await this.metamaskProvider.request({method:"eth_requestAccounts"});let{chainId:t}=this.metamaskProvider;if(t!==this.chainConfig.chainId&&await this.switchChain(this.chainConfig),this.status=s.MP.CONNECTED,!this.provider)throw s.RM.notConnectedError("Failed to connect with provider");return this.provider.once("disconnect",()=>{this.disconnect()}),this.emit(s.n2.CONNECTED,{adapter:s.rW.METAMASK,reconnected:this.rehydrated}),this.provider}catch(t){throw this.status=s.MP.READY,this.rehydrated=!1,this.emit(s.n2.ERRORED,t),s.RM.connectionError("Failed to login with metamask wallet")}}async disconnect(){var t;let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnectSession(),null===(t=this.provider)||void 0===t||t.removeAllListeners(),e.cleanup?(this.status=s.MP.NOT_READY,this.metamaskProvider=null):this.status=s.MP.READY,await super.disconnect()}async getUserInfo(){if(this.status!==s.MP.CONNECTED)throw s.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(t){if(!this.metamaskProvider)throw s.RM.notConnectedError("Not connected with wallet");try{await this.metamaskProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:t.chainId}]})}catch(e){if(4902===e.code)await this.metamaskProvider.request({method:"wallet_addEthereumChain",params:[{chainId:t.chainId,chainName:t.displayName,rpcUrls:[t.rpcTarget],blockExplorerUrls:[t.blockExplorer],nativeCurrency:{name:t.tickerName,symbol:t.ticker,decimals:t.decimals||18}}]});else throw e}}}}}]);