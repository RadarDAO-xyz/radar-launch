"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[487],{57217:function(e,t,i){i.d(t,{OpenloginAdapter:function(){return P},getOpenloginDefaultOptions:function(){return g}});var n=i(91341),o=i(4942),r=i(61674),s=i(59506);i(79826);var a=i(90215),l=i(23420),h=i.n(l);class c{constructor(){(0,o.Z)(this,"_providerEngineProxy",null)}get provider(){return this._providerEngineProxy}set provider(e){throw Error("Method not implemented.")}addChain(e){throw Error("Method not implemented.")}async setupProvider(e){let t=this.getPrivKeyMiddleware(e),i=new a.eI;i.push(t);let n=(0,s.Xj)(i);this.updateProviderEngineProxy(n)}async switchChain(e){return Promise.resolve()}getProviderEngineProxy(){return this._providerEngineProxy}updateProviderEngineProxy(e){this._providerEngineProxy?this._providerEngineProxy.setTarget(e):this._providerEngineProxy=(0,s.qY)(e)}getPrivKeyMiddleware(e){return this.createPrivKeyMiddleware({getPrivatekey:async()=>e})}createPrivKeyMiddleware(e){let{getPrivatekey:t}=e;async function i(e,i){i.result=await t()}return(0,a.v0)({private_key:(0,a.Pk)(i)})}}(0,o.Z)(c,"getProviderInstance",async e=>{let t=new c;return await t.setupProvider(e.privKey),t}),h()();var p=i(72378),d=i.n(p);let g=()=>({adapterSettings:{network:n.dr.MAINNET,clientId:"",uxMode:n.$e.POPUP},loginSettings:{}});function u(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),i.push.apply(i,n)}return i}function v(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?u(Object(i),!0).forEach(function(t){(0,o.Z)(e,t,i[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):u(Object(i)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))})}return e}class P extends r.J5{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(e),(0,o.Z)(this,"name",r.rW.OPENLOGIN),(0,o.Z)(this,"adapterNamespace",r.yk.MULTICHAIN),(0,o.Z)(this,"type",r.hN.IN_APP),(0,o.Z)(this,"openloginInstance",null),(0,o.Z)(this,"status",r.MP.NOT_READY),(0,o.Z)(this,"currentChainNamespace",r.EN.EIP155),(0,o.Z)(this,"openloginOptions",void 0),(0,o.Z)(this,"loginSettings",{loginProvider:""}),(0,o.Z)(this,"privKeyProvider",null),this.setAdapterSettings(v(v({},e.adapterSettings),{},{chainConfig:e.chainConfig,clientId:e.clientId||"",sessionTime:e.sessionTime,web3AuthNetwork:e.web3AuthNetwork,useCoreKitKey:e.useCoreKitKey})),this.loginSettings=e.loginSettings||{loginProvider:""}}get chainConfigProxy(){return this.chainConfig?v({},this.chainConfig):null}get provider(){var e;return(null===(e=this.privKeyProvider)||void 0===e?void 0:e.provider)||null}set provider(e){throw Error("Not implemented")}async init(e){if(super.checkInitializationRequirements(),!this.clientId)throw r.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.openloginOptions)throw r.Ty.invalidParams("openloginOptions is required before openlogin's initialization");let t=!1;if(this.openloginOptions.uxMode===n.$e.REDIRECT||this.openloginOptions.uxMode===n.$e.SESSIONLESS_REDIRECT){let e=(0,n.Gv)();Object.keys(e).length>0&&e._pid&&(t=!0)}this.openloginOptions=v(v({},this.openloginOptions),{},{replaceUrlOnRedirect:t}),this.openloginInstance=new n.ZP(v(v({},this.openloginOptions),{},{clientId:this.clientId,network:this.openloginOptions.network||this.web3AuthNetwork||n.dr.MAINNET})),r.cM.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=r.MP.READY,this.emit(r.n2.READY,r.rW.OPENLOGIN);try{r.cM.debug("initializing openlogin adapter");let i=this._getFinalPrivKey();i&&(e.autoConnect||t)&&(this.rehydrated=!0,await this.connect())}catch(e){r.cM.error("Failed to connect with cached openlogin provider",e),this.emit("ERRORED",e)}}async connect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};super.checkConnectionRequirements(),this.status=r.MP.CONNECTING,this.emit(r.n2.CONNECTING,v(v({},e),{},{adapter:r.rW.OPENLOGIN}));try{return await this.connectWithProvider(e),this.provider}catch(e){if(r.cM.error("Failed to connect with openlogin provider",e),this.status=r.MP.READY,this.emit(r.n2.ERRORED,e),null!=e&&e.message.includes("user closed popup"))throw r.RM.popupClosed();throw r.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),e.cleanup?(this.status=r.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=r.MP.READY,this.rehydrated=!1,this.emit(r.n2.DISCONNECTED)}async authenticateUser(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet, Please login/connect first");let e=await this.getUserInfo();return{idToken:e.idToken}}async getUserInfo(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");let e=await this.openloginInstance.getUserInfo();return e}setAdapterSettings(e){super.setAdapterSettings(e);let t=g();r.cM.info("setting adapter settings",e),this.openloginOptions=v(v(v({},t.adapterSettings),this.openloginOptions),e),e.web3AuthNetwork&&(this.openloginOptions.network=e.web3AuthNetwork),void 0!==e.useCoreKitKey&&(this.openloginOptions.useCoreKitKey=e.useCoreKitKey)}_getFinalPrivKey(){var e;if(!this.openloginInstance)return"";let t=this.openloginInstance.privKey;return null!==(e=this.openloginOptions)&&void 0!==e&&e.useCoreKitKey&&this.openloginInstance.coreKitKey&&(t=this.openloginInstance.coreKitKey),t}async connectWithProvider(){var e,t;let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};if(!this.chainConfig)throw r.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");if(this.currentChainNamespace===r.EN.SOLANA){let{SolanaPrivateKeyProvider:e}=await Promise.all([i.e(766),i.e(108),i.e(90),i.e(833)]).then(i.bind(i,4245));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===r.EN.EIP155){let{EthereumPrivateKeyProvider:e}=await Promise.all([i.e(954),i.e(755)]).then(i.bind(i,2954));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===r.EN.OTHER)this.privKeyProvider=new c;else throw Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);let s=this._getFinalPrivKey();if(!s||null!==(e=o.extraLoginOptions)&&void 0!==e&&e.id_token){if(this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===r.EN.SOLANA?n.x7.ED25519:n.x7.SECP256K1),!o.loginProvider&&!this.loginSettings.loginProvider)throw r.Ty.invalidParams("loginProvider is required for login");await this.openloginInstance.login(d()(this.loginSettings,o,{extraLoginOptions:v(v({},o.extraLoginOptions||{}),{},{login_hint:o.login_hint||(null===(t=o.extraLoginOptions)||void 0===t?void 0:t.login_hint)})}))}let a=this._getFinalPrivKey();if(a){if(this.currentChainNamespace===r.EN.SOLANA){let{getED25519Key:e}=await Promise.all([i.e(108),i.e(418)]).then(i.bind(i,33946));a=e(a).sk.toString("hex")}await this.privKeyProvider.setupProvider(a),this.status=r.MP.CONNECTED,this.emit(r.n2.CONNECTED,{adapter:r.rW.OPENLOGIN,reconnected:this.rehydrated})}}}}}]);